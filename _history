{"entries":[{"timestamp":1741236823062,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"Kiddo.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":223,"start2":223,"length1":65,"length2":44}]},{"type":"added","filename":"Kiddo.ts","value":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n"}]},{"timestamp":1741236845382,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"Kiddo.ts","patch":[{"diffs":[[1,"\n"],[0,"/**\n"],[-1," "],[0,"* "],[-1,"Custom blocks for Kiddo\n */\nconst enum IrButton {\n    //% block=\"CH-\"\n    CHreduce = 0xa2,\n    //% block=\"CH\"\n    CH = 0x62,\n    //% block=\"CH+\"\n    CHadd = 0xe2,\n    //% block=\"⏮\"\n    Fastrewind = 0x22,\n    //% block=\"⏭\"\n    Fastforward = 0x02,\n    //% block=\"⏯\"\n    Play = 0xc2,\n    //% block=\"-\"\n    Reduce = 0xe0,\n    //% block=\"+\"\n    Add = 0xa8,\n    //% block=\"EQ\"\n    EQ = 0x90,\n    //% block=\"0\"\n    Number_0 = 0x68,\n    //% block=\"100+\"\n    Number_100 = 0x98,\n    //% block=\"200+\"\n    Number_200 = 0xb0,\n    //% block=\"1\"\n    Number_1 = 0x30,\n    //% block=\"2\"\n    Number_2 = 0x18,\n    //% block=\"3\"\n    Number_3 = 0x7a,\n    //% block=\"4\"\n    Number_4 = 0x10,\n    //% block=\"5\"\n    Number_5 = 0x38,\n    //% block=\"6\"\n    Number_6 = 0x5a,\n    //% block=\"7\"\n    Number_7 = 0x42,\n    //% block=\"8\"\n    Number_8 = 0x4a,\n    //% block=\"9\"\n    Number_9 = 0x52,\n    //% block=\"any\"\n    Any = -1,\n}\n\nconst enum IrButtonAction {\n    //% block=\"pressed\"\n    Pressed = 0,\n    //% block=\"released\"\n    Released = 1,\n}\n\n//% weight=100 color=#993366 icon=\"\\uf2db\" block=\"Kiddo\"\nnamespace KiddoRobot {\n\n    // Define custom enums for digital pins\n    export enum kiddoDigitalPin {\n        //% block=\"P3\"\n        P3 = DigitalPin.P3,\n        //% block=\"P4\"\n        P4 = DigitalPin.P4,\n        //% block=\"P5\"\n        P5 = DigitalPin.P5,\n        //% block=\"P6\"\n        P6 = DigitalPin.P6,\n        //% block=\"P7\"\n        P7 = DigitalPin.P7,\n        //% block=\"P10\"\n        P10 = DigitalPin.P10,\n        //% block=\"P11\"\n        P11 = DigitalPin.P11,\n        //% block=\"P19\"\n        P19 = DigitalPin.P19,\n        //% block=\"P20\"\n        P20 = DigitalPin.P20\n    }\n\n    // Define custom enums for analog pins\n    export enum kiddoAnalogPin {\n        //% block=\"P3\"\n        P3 = AnalogPin.P3,\n        //% block=\"P4\"\n        P4 = AnalogPin.P4,\n        //% block=\"P10\"\n        P10 = AnalogPin.P10\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    ////////////////////\n    //  PINS  //\n    ////////////////////\n\n    // Function for reading a digital value from a pin\n    //% subcategory=\"Pins\"\n    //% group=\"Digital Pins\"\n    //% weight=150 blockGap=8\n    //% blockId=\"digital_read\"\n    //% block=\"read digital pin %pin\"\n    export function digitalRead(pin: kiddoDigitalPin): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    // Function for writing a digital value to a pin\n    //% subcategory=\"Pins\"\n    //% group=\"Digital Pins\"\n    //% blockId=\"digital_write\"\n    //% weight=140 blockGap=50\n    //% block=\"write digital pin %pin |to %value\"\n    export function digitalWrite(pin: kiddoDigitalPin, value: number): void {\n        pins.digitalWritePin(pin, value);\n    }\n\n    // Function for reading an analog value from a pin\n    //% subcategory=\"Pins\"\n    //% group=\"Analog Pins\"\n    //% blockId=\"analog_read\"\n    //% weight=130 blockGap=8\n    //% block=\"read analog pin %pin\"\n    export function analogRead(pin: kiddoAnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    // Function for writing an analog value to a pin\n    //% subcategory=\"Pins\"\n    //% group=\"Analog Pins\"\n    //% weight=120 blockGap=8\n    //% blockId=\"analog_write\"\n    //% block=\"write analog pin %pin |to %value\"\n    //% value.min=0 value.max=1023\n    export function analogWrite(pin: AnalogPin, value: number): void {\n        pins.analogWritePin(pin, value);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////\n    //  Sensors //\n    ////////////////////\n\n\n    // IR Sensor \n\n    // Hardcoded sensor pins\n    const RIGHT_SENSOR_PIN: AnalogPin = AnalogPin.P1; // Right sensor on P1\n    const LEFT_SENSOR_PIN: AnalogPin = AnalogPin.P2;  // Left sensor on P2\n\n    // Fixed thresholds for black and white surfaces\n    const RIGHT_SENSOR_THRESHOLD: number = 5.2; // Fixed threshold for right sensor\n    const LEFT_SENSOR_THRESHOLD: number = 5.2;  // Fixed threshold for left sensor\n\n    /**\n     * Initialize the line follower sensors with default pins (P1 and P2).\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"Line Follower\"\n    //% block=\"initialize line follower\"\n    //% weight=100\n    export function initializeLineFollower(): void {\n        // No initialization logic needed since thresholds are fixed\n    }\n\n    /**\n     * Read the sensor value from the right sensor.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"Line Follower\"\n    //% block=\"read right sensor\"\n    //% weight=90\n    export function readRightLineFollowerSensor(): number {\n        let rawValue = pins.analogReadPin(RIGHT_SENSOR_PIN);\n        return (rawValue < RIGHT_SENSOR_THRESHOLD) ? 1 : 0; // 1 for black, 0 for white\n    }\n\n    /**\n     * Read the sensor value from the left sensor.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"Line Follower\"\n    //% block=\"read left sensor\"\n    //% weight=80\n    export function readLeftLineFollowerSensor(): number {\n        let rawValue = pins.analogReadPin(LEFT_SENSOR_PIN);\n        return (rawValue < LEFT_SENSOR_THRESHOLD) ? 1 : 0; // 1 for black, 0 for white\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    //Ultrasonic Sensor\n\n    // Ultrasonic sensor pins\n    const ULTRASONIC_TRIG_PIN = DigitalPin.P8; // Default TRIG pin\n    const ULTRASONIC_ECHO_PIN = DigitalPin.P9; // Default ECHO pin\n\n    // Enum for Distance Units\n    export enum Unit {\n   "],[1,"Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n"],[0,"    "],[-1," "],[0,"//% "]],"start1":0,"start2":0,"length1":5445,"length2":145},{"diffs":[[0,"ck=\""],[-1,"cm\"\n        Centimeters,\n        //% block=\"inches\"\n        Inches\n    }\n\n    /**\n     * Initialize the ultrasonic sensor.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"Obstacle Detection\"\n    //% block=\"initialize ultrasonic sensor\"\n    //% weight=110\n    export function initializeUltrasonicSensor(): void {\n        // Configure TRIG pin as output\n        pins.setPull(ULTRASONIC_TRIG_PIN, PinPullMode.PullNone);\n        pins.digitalWritePin(ULTRASONIC_TRIG_PIN, 0); // Set TRIG pin low initially\n\n        // Configure ECHO pin as input\n        pins.setPull(ULTRASONIC_ECHO_PIN, PinPullMode.PullNone);\n    }\n\n    /**\n     * Detect obstacle distance using ultrasonic sensor\n     * @param unit Desired distance unit (cm or inches)\n     * @param maxCmDistance Maximum measurable distance in centimeters (default is 500)\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"Obstacle Detection\"\n    //% block=\"detect obstacle distance in %unit\"\n    //% weight=100\n    //% unit.defl=Unit.Centimeters\n    export function detectObstacleDistance(unit: Unit, maxCmDistance = 500): number {\n        // Send pulse to trigger ultrasonic sensor\n        pins.digitalWritePin(ULTRASONIC_TRIG_PIN, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(ULTRASONIC_TRIG_PIN, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(ULTRASONIC_TRIG_PIN, 0);\n\n        // Read pulse duration from echo pin\n        const d = pins.pulseIn(ULTRASONIC_ECHO_PIN, PulseValue.High, maxCmDistance * 58);\n\n        // Handle case where no echo is received\n        if (d === 0) {\n            return -1; // Return -1 for no response\n        }\n\n        // Convert pulse duration to distance\n        switch (unit) {\n            case Unit.Centimeters:\n                return Math.idiv(d, 58); // Convert to cm\n            case Unit.Inches:\n                return Math.idiv(d, 148); // Convert to inches\n            default:\n                return -1;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n\n    //IR Receiver\n\n    let irState: IrState;\n\n    const IR_REPEAT = 256;\n    const IR_INCOMPLETE = 257;\n    const IR_DATAGRAM = 258;\n\n    const REPEAT_TIMEOUT_MS = 120;\n\n    interface IrState {\n        hasNewDatagram: boolean;\n        bitsReceived: uint8;\n        addressSectionBits: uint16;\n        commandSectionBits: uint16;\n        hiword: uint16;\n        loword: uint16;\n        activeCommand: number;\n        repeatTimeout: number;\n        onIrButtonPressed: IrButtonHandler[];\n        onIrButtonReleased: IrButtonHandler[];\n        onIrDatagram: () => void;\n    }\n\n    class IrButtonHandler {\n        irButton: IrButton;\n        onEvent: () => void;\n\n        constructor(irButton: IrButton, onEvent: () => void) {\n            this.irButton = irButton;\n            this.onEvent = onEvent;\n        }\n    }\n\n    function appendBitToDatagram(bit: number): number {\n        irState.bitsReceived += 1;\n\n        if (irState.bitsReceived <= 8) {\n            irState.hiword = (irState.hiword << 1) + bit;\n        } else if (irState.bitsReceived <= 16) {\n            irState.hiword = (irState.hiword << 1) + bit;\n        } else if (irState.bitsReceived <= 32) {\n            irState.loword = (irState.loword << 1) + bit;\n        }\n\n        if (irState.bitsReceived === 32) {\n            irState.addressSectionBits = irState.hiword & 0xffff;\n            irState.commandSectionBits = irState.loword & 0xffff;\n            return IR_DATAGRAM;\n        } else {\n            return IR_INCOMPLETE;\n        }\n    }\n\n    function decode(markAndSpace: number): number {\n        if (markAndSpace < 1600) {\n            // low bit\n            return appendBitToDatagram(0);\n        } else if (markAndSpace < 2700) {\n            // high bit\n            return appendBitToDatagram(1);\n        }\n\n        irState.bitsReceived = 0;\n\n        if (markAndSpace < 12500) {\n            // Repeat detected\n            return IR_REPEAT;\n        } else if (markAndSpace < 14500) {\n            // Start detected\n            return IR_INCOMPLETE;\n        } else {\n            return IR_INCOMPLETE;\n        }\n    }\n\n    function enableIrMarkSpaceDetection(pin: DigitalPin) {\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        let mark = 0;\n        let space = 0;\n\n        pins.onPulsed(pin, PulseValue.Low, () => {\n            mark = pins.pulseDuration();\n        });\n\n        pins.onPulsed(pin, PulseValue.High, () => {\n            space = pins.pulseDuration();\n            const status = decode(mark + space);\n\n            if (status !== IR_INCOMPLETE) {\n                handleIrEvent(status);\n            }\n        });\n    }\n\n    function handleIrEvent(irEvent: number) {\n        if (irEvent === IR_DATAGRAM || irEvent === IR_REPEAT) {\n            irState.repeatTimeout = input.runningTime() + REPEAT_TIMEOUT_MS;\n        }\n\n        if (irEvent === IR_DATAGRAM) {\n            irState.hasNewDatagram = true;\n\n            if (irState.onIrDatagram) {\n                control.inBackground(() => {\n                    irState.onIrDatagram();\n                });\n            }\n\n            const newCommand = irState.commandSectionBits >> 8;\n\n            if (newCommand !== irState.activeCommand) {\n                if (irState.activeCommand >= 0) {\n                    const releasedHandler = irState.onIrButtonReleased.find(h => h.irButton === irState.activeCommand || IrButton.Any === h.irButton);\n                    if (releasedHandler) {\n                        control.inBackground(() => {\n                            releasedHandler.onEvent();\n                        });\n                    }\n                }\n\n                const pressedHandler = irState.onIrButtonPressed.find(h => h.irButton === newCommand || IrButton.Any === h.irButton);\n                if (pressedHandler) {\n                    control.inBackground(() => {\n                        pressedHandler.onEvent();\n                    });\n                }\n\n                irState.activeCommand = newCommand;\n            }\n        }\n    }\n\n    function initIrState() {\n        if (irState) {\n            return;\n        }\n\n        irState = {\n            hasNewDatagram: false,\n            bitsReceived: 0,\n            addressSectionBits: 0,\n            commandSectionBits: 0,\n            hiword: 0,\n            loword: 0,\n            activeCommand: -1,\n            repeatTimeout: 0,\n            onIrButtonPressed: [],\n            onIrButtonReleased: [],\n            onIrDatagram: undefined,\n        };\n    }\n\n    /**\n     * Initializes the IR receiver at pin P0.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=kiddo_infrared_initialize_receiver\n    //% block=\"Initialize IR Receiver\"\n    //% weight=90\n    export function initializeIrReceiver(): void {\n        initIrState();\n        enableIrMarkSpaceDetection(DigitalPin.P0); // Fixed to P0\n        control.inBackground(() => {\n            while (true) {\n                notifyIrEvents();\n                basic.pause(REPEAT_TIMEOUT_MS);\n            }\n        });\n    }\n\n    function notifyIrEvents() {\n        if (irState.activeCommand === -1) {\n            return;\n        }\n\n        const now = input.runningTime();\n        if (now > irState.repeatTimeout) {\n            const handler = irState.onIrButtonReleased.find(h => h.irButton === irState.activeCommand || IrButton.Any === h.irButton);\n            if (handler) {\n                control.inBackground(() => {\n                    handler.onEvent();\n                });\n            }\n\n            irState.bitsReceived = 0;\n            irState.activeCommand = -1;\n        }\n    }\n\n    /**\n     * Do something when a specific button is pressed or released on the remote control.\n     * @param button the button to be checked\n     * @param action the trigger action\n     * @param handler body code to run when the event is raised\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=kiddo_infrared_on_ir_button\n    //% block=\"on IR button | %button | %action\"\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.columns=3\n    //% button.fieldOptions.tooltips=\"false\"\n    //% weight=50\n    export function onIrButton(button: IrButton, action: IrButtonAction, handler: () => void) {\n        initIrState();\n        if (action === IrButtonAction.Pressed) {\n            irState.onIrButtonPressed.push(new IrButtonHandler(button, handler));\n        } else {\n            irState.onIrButtonReleased.push(new IrButtonHandler(button, handler));\n        }\n    }\n\n    /**\n     * Returns the code of the IR button that was pressed last. Returns -1 (IrButton.Any) if no button has been pressed yet.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=kiddo_infrared_ir_button_pressed\n    //% block=\"IR button Values\"\n    //% weight=70\n    export function irButton(): number {\n        basic.pause(0); // Yield to support background processing\n        if (!irState) {\n            return IrButton.Any;\n        }\n        return irState.commandSectionBits >> 8;\n    }\n\n    /**\n     * Do something when an IR datagram is received.\n     * @param handler body code to run when the event is raised\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=kiddo_infrared_on_ir_datagram\n    //% block=\"on IR datagram received\"\n    //% weight=40\n    export function onIrDatagram(handler: () => void) {\n        initIrState();\n        irState.onIrDatagram = handler;\n    }\n\n    /**\n     * Returns the IR datagram as a 32-bit hexadecimal string.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=kiddo_infrared_ir_datagram\n    //% block=\"IR datagram\"\n    //% weight=30\n    export function irDatagram(): string {\n        basic.pause(0); // Yield to support background processing\n        initIrState();\n        return \"0x\" + ir_rec_to16BitHex(irState.addressSectionBits) + ir_rec_to16BitHex(irState.commandSectionBits);\n    }\n\n    /**\n     * Returns the command code of a specific IR button.\n     * @param button the button\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=kiddo_infrared_button_code\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.columns=3\n    //% button.fieldOptions.tooltips=\"false\"\n    //% block=\"IR button code %button\"\n    //% weight=60\n    export function irButtonCode(button: IrButton): number {\n        basic.pause(0); // Yield to support background processing\n        return button as number;\n    }\n\n    function ir_rec_to16BitHex(value: number): string {\n        let hex = \"\";\n        for (let pos = 0; pos < 4; pos++) {\n            let remainder = value % 16;\n            if (remainder < 10) {\n                hex = remainder.toString() + hex;\n            } else {\n                hex = String.fromCharCode(55 + remainder) + hex;\n            }\n            value = Math.idiv(value, 16);\n        }\n        return hex;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    ////////////////////\n    //  Actuators //\n    ////////////////////\n\n    // DC Motor\n\n    // Motor control pins\n    const R_PIN1 = DigitalPin.P14;\n    const R_PIN2 = DigitalPin.P13;\n    const L_PIN1 = DigitalPin.P15;\n    const L_PIN2 = DigitalPin.P16;\n\n    // Define motor enum\n    export enum Motor {\n        //% block=\"R\"\n        R,\n        //% block=\"L\"\n        L\n    }\n\n    // Define direction enum\n    export enum Direction {\n        //% block=\"forward\"\n        Forward,\n        //% block=\"backward\"\n        Backward\n    }\n\n    // Define turn enum\n    export enum Turn {\n        //% block=\"left\"\n        Left,\n        //% block=\"right\"\n        Right\n    }\n\n    // Control a specific motor in a direction at a given speed\n    //% subcategory=\"Actuators\"\n    //% group=\"Motors\"\n    //% block=\"motor %motor direction %direction at speed %speed\"\n    //% speed.min=0 speed.max=100\n    //% weight=100\n\n    export function controlMotor(motor: Motor, direction: Direction, speed: number): void {\n        let pwmSpeed = Math.map(speed, 0, 100, 0, 1023);\n\n        if (motor === Motor.R) {\n            if (direction === Direction.Forward) {\n                pins.analogWritePin(R_PIN1, pwmSpeed);\n                pins.digitalWritePin(R_PIN2, 0);\n            } else if (direction === Direction.Backward) {\n                pins.digitalWritePin(R_PIN1, 0);\n                pins.analogWritePin(R_PIN2, pwmSpeed);\n            }\n        } else if (motor === Motor.L) {\n            if (direction === Direction.Forward) {\n                pins.analogWritePin(L_PIN1, pwmSpeed);\n                pins.digitalWritePin(L_PIN2, 0);\n            } else if (direction === Direction.Backward) {\n                pins.digitalWritePin(L_PIN1, 0);\n                pins.analogWritePin(L_PIN2, pwmSpeed);\n            }\n        }\n    }\n\n    // Stop a specific motor\n    //% subcategory=\"Actuators\"\n    //% group=\"Motors\"\n    //% block=\"stop motor %motor\"\n    //% weight=90\n\n    export function stopMotor(motor: Motor): void {\n        if (motor === Motor.R) {\n            pins.digitalWritePin(R_PIN1, 0);\n            pins.digitalWritePin(R_PIN2, 0);\n        } else if (motor === Motor.L) {\n            pins.digitalWritePin(L_PIN1, 0);\n            pins.digitalWritePin(L_PIN2, 0);\n        }\n    }\n\n    // Stop all motors\n    //% subcategory=\"Actuators\"\n    //% group=\"Motors\"\n    //% block=\"stop all motors\"\n    //% weight=80\n\n    export function stopAllMotors(): void {\n        pins.digitalWritePin(R_PIN1, 0);\n        pins.digitalWritePin(R_PIN2, 0);\n        pins.digitalWritePin(L_PIN1, 0);\n        pins.digitalWritePin(L_PIN2, 0);\n    }\n\n    // Move both motors forward or backward at the same speed\n    //% subcategory=\"Actuators\"\n    //% group=\"Motors\"\n    //% block=\"move %direction at speed %speed\"\n    //% speed.min=0 speed.max=100\n    //% weight=60\n\n    export function move(direction: Direction, speed: number): void {\n        let pwmSpeed = Math.map(speed, 0, 100, 0, 1023);\n\n        if (direction === Direction.Forward) {\n            // Move forward: M1 and M2 forward\n            pins.analogWritePin(R_PIN1, pwmSpeed);\n            pins.digitalWritePin(R_PIN2, 0);\n            pins.analogWritePin(L_PIN1, pwmSpeed);\n            pins.digitalWritePin(L_PIN2, 0);\n        } else if (direction === Direction.Backward) {\n            // Move backward: M1 and M2 backward\n            pins.digitalWritePin(R_PIN1, 0);\n            pins.analogWritePin(R_PIN2, pwmSpeed);\n            pins.digitalWritePin(L_PIN1, 0);\n            pins.analogWritePin(L_PIN2, pwmSpeed);\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////\n\n    //RGB LED\n\n    // NeoPixel LED strip pin (hardcoded to P12)\n    const LED_PIN: DigitalPin = DigitalPin.P12; // LED pin is fixed to P12\n    const NUM_LEDS = 8; // Number of LEDs in the strip\n\n    // LED buffer\n    let ledBuffer: Buffer = control.createBuffer(NUM_LEDS * 3); // Initialize buffer once\n\n\n    /**\n     * Initialize the NeoPixel LED strip and clear it by default.\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"RGB LED\"\n    //% block=\"Kiddo initialize LED\"\n    //% weight=100\n\n    export function initializeLedStrip(): void {\n        // Clear the LED buffer (turn off all LEDs)\n        ledBuffer.fill(0);\n\n        // Reset the data line\n        pins.digitalWritePin(LED_PIN, 0);\n        control.waitMicros(50); // Wait for the strip to reset\n\n        // Updat"],[1,"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add cod"],[0,"e "],[-1,"t"],[0,"he"],[-1," LED strip to apply the cleared state\n        updateLedStrip();\n    }\n\n    /**\n     * Set the color of the entire LED strip.\n     * @param color The color to set the LED strip to (in RGB format).\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"RGB LED\"\n    //% block=\"Kiddo set LED color %color\"\n    //% weight=90\n\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setLedColor(color: number): void {\n        // Extract RGB components from the color value\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        // Set the color for each LED\n        for (let i = 0; i < NUM_LEDS; i++) {\n            let offset = i * 3;\n            ledBuffer[offset] = green; // GRB format\n            ledBuffer[offset + 1] = red;\n            ledBuffer[offset + 2] = blue;\n        }\n\n        // Update the LED strip\n        updateLedStrip();\n    }\n\n    /**\n     * Clear the LED strip (turn off all LEDs).\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"RGB LED\"\n    //% block=\"Kiddo clear LED\"\n    //% weight=80\n\n    export function clearLed(): void {\n        // Fill the buffer with zeros (turn off all LEDs)\n        for (let i = 0; i < NUM_LEDS * 3; i++) {\n            ledBuffer[i] = 0;\n        }\n\n        // Update the LED strip\n        updateLedStrip();\n    }\n\n    // Helper function to update the LED strip with the current buffer data\n    function updateLedStrip(): void {\n        // Send the buffer data to the NeoPixel strip\n        light.sendWS2812Buffer(ledBuffer, LED_PIN);\n    }\n\n    //% subcategory=\"Actuators\"\n    //% group=\"RGB LED\"\n    //% blockId=brightColorNumberPicker\n    //% block=\"%value\"\n    //% shim=TD_ID\n    //% colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\"\n    //% value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#FF0000\",\"#00FF00\",\"#0000FF\",\"#FFFF00\",\"#00FFFF\",\"#FF00FF\",\"#FFFFFF\",\"#000000\"]'\n    //% value.fieldOptions.columns=8\n    //% value.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(value: number): number {\n        return value;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n\n    // Servo Motor\n\n    // Convert any DigitalPinPrime to a valid DigitalPin (for PWM control)\n    function getDigitalPin(pin: DigitalPin): DigitalPin {\n        // Return the pin directly (assuming it's a valid digital pin)\n        return pin;\n    }\n\n\n    // Define servo positions enumeration\n    export enum ServoPosition {\n        //% block=\"0 degrees\"\n        Zero = 0,\n        //% block=\"45 degrees\"\n        FortyFive = 45,\n        //% block=\"90 degrees\"\n        Ninety = 90,\n        //% block=\"135 degrees\"\n        OneThirtyFive = 135,\n        //% block=\"180 degrees\"\n        OneEighty = 180\n    }\n\n\n    /**\n    * Moves a servo to a specified position.\n    * @param pin which pin to control\n    * @param position the position to move to\n    */\n    //% subcategory=\"Actuators\"\n    //% weight=150 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    //% position.min=0 position.max=180\n    export function movePositionalServo(pin: DigitalPin, position: number): void {\n        const angle = Math.clamp(0, 180, position);  // Ensure angle is within 0-180 range\n        pins.servoWritePin(getDigitalPin(pin), angle);\n    }\n\n    /**\n     * Moves a servo to a specified position.\n     * @param pin which pin to control\n     * @param position the position to move to\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=120 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo_to_fixed_point\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    export function movePositionalServofixed(pin: DigitalPin, position: ServoPosition): void {\n        // Using the ServoPosition enum, which already contains the angle values\n        pins.servoWritePin(getDigitalPin(pin), position);  // position is directly the angle in degrees\n    }\n\n    //% subcategory=\"Actuators\"\n    //% weight=10 blockGap=8\n    //% group=\"Positional Servo\" \n    //% blockId=\"move_servo_from_to\"\n    //% block=\"move servo on pin %pin|from angle %from|to angle %to|over %duration seconds\"\n    //% from.min=0 from.max=180\n    //% to.min=0 to.max=180\n    //% duration.min=1 duration.max=10\n    export function moveServoFromTo1(pin: DigitalPin, from"],[1,"re\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value"],[0,": number"],[-1,", to"],[1,")"],[0,": number"],[-1,", duration: number): void {\n        const startAngle = Math.clamp(0, 180, from);\n        const endAngle = Math.clamp(0, 180, to);\n        const steps = Math.abs(endAngle - startAngle);\n        const stepDuration = duration * 1000 / steps;\n\n        // Loop through each step and move the servo\n        for (let i = 0; i <= steps; i++) {\n            // Calculate the current angle for the servo based on the direction of movement\n            const currentAngle = startAngle + (endAngle > startAngle ? i : -i);\n\n            // Ensure that we don't exceed the target angle, especially when rounding\n            if ((endAngle > startAngle && currentAngle >= endAngle) || (endAngle < startAngle && currentAngle <= endAngle)) {\n                // Set the final angle to the target and break the loop\n                pins.servoWritePin(getDigitalPin(pin), endAngle);\n                break; // exit the loop once we reach the target angle\n            } else {\n                // Otherwise, move the servo to the current calculated angle\n                pins.servoWritePin(getDigitalPin(pin), currentAngle);\n            }\n\n            // Pause for the time before moving to the next step\n            basic.pause(stepDuration);\n        }\n    }\n\n    /**\n     * Controls the speed and direction of a continuous rotation servo.\n     * @param pin which pin to control\n     * @param speed the speed of the servo motor (-100 to 100)\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=40 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"move_continuous_servo\"\n    //% block=\"set continuous servo on pin %pin|to speed %speed\"\n    //% speed.min=-100 speed.max=100\n    export function moveContinuousServo(pin: DigitalPin, speed: number): void {\n        const speedValue = Math.clamp(-100, 100, speed);  // Ensure speed is within -100 to 100 range\n\n        // Map speed to the correct PWM values (using -100 for full reverse and 100 for full forward)\n        const pwmValue = Math.map(speedValue, -100, 100, 0, 180);  // 40-120 range typically works for continuous servos\n\n        // Write the PWM value to the pin\n        pins.servoWritePin(getDigitalPin(pin), pwmValue);\n    }\n\n    /**\n     * Stops the continuous rotation servo.\n     * @param pin which pin to control\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=30 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"stop_continuous_servo\"\n    //% block=\"stop continuous servo on pin %pin\"\n    export function stopContinuousServo(pin: DigitalPin): void {\n        // Set speed to 0 to stop the motor\n        pins.servoWritePin(getDigitalPin(pin), 90);  // 90 typically stops a continuous servo\n    "],[1," {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n"],[0,"}\n"],[-1,"}"]],"start1":148,"start2":148,"length1":22645,"length2":682}]}]},{"timestamp":1741237810779,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"><block "],[1,"type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block "],[0,"type=\"de"]],"start1":77,"start2":77,"length1":16,"length2":65}]}]},{"timestamp":1741237816174,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"ver\""],[-1," id=\"8HHT~8[mPv-`v)WXXv^y\""],[0," x=\"2"],[-1,"0"],[1,"25"],[0,"\" y="]],"start1":102,"start2":102,"length1":40,"length2":15}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"icon\": \"icon.png"],[1,"preferredEditor\": \"tsprj"],[0,"\"\n}\n"]],"start1":256,"start2":256,"length1":100,"length2":32}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1741236823061,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Kiddo_Blocks\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1741237905718}